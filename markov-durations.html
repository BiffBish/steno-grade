<!DOCTYPE html>
<html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="utf-8" />
        <title>Markov-chain generated sentences</title>
        <link href="base.css" rel="stylesheet" type="text/css" />
        <link href="style.less" rel="stylesheet/less" type="text/css" />
        <script src="scripts/type-jig.js"></script>
        <script src="scripts/utils/util.js"></script>
        <script src="scripts/utils/steno-display.js"></script>
        <script src="data/plover-translations.js"></script>
        <script src="data/tatoeba-sentences.js"></script>
        <script src="scripts/libs/jquery-3.6.0.min.js"></script>

        <script src="scripts/libs/less.js" ></script>
        <script src="scripts/libs/chart.js"></script>
        <script src="scripts/libs/chartjs-plugin-datalabels.js"></script>
        <script src="scripts/spectra/spectra.js"></script>
        <script src="scripts/spectra/rules.js"></script>
        <link rel="stylesheet" type="text/css" href="font-roboto.css" />
    </head>
    <body>
        <div id="lesson" class="wrapper"></div>
    </body>
    <script>
        setTheme();

        function compute_ngrams(sentences, order) {
            const ngrams = { "": [] };
            for (let i = 0; i < sentences.length; ++i) {
                const words = sentences[i].split(/\s+/);
                for (let j = 0; j < words.length - order; ++j) {
                    const Gram = words.slice(j, j + order).join(" ");
                    if (j === 0) ngrams[""].push(Gram);
                    const gram = Gram.toLowerCase();
                    const next = words[j + order];
                    if (ngrams[gram] == null) ngrams[gram] = [];
                    ngrams[gram].push(next);
                }
            }
            return ngrams;
        }

        function generate_sentence(ngrams, rnd, bias) {
            const durationData = JSON.parse(
                localStorage.getItem("durations") ?? "{}"
            );
            const durationDataItems = Object.entries(durationData);
            //Remove all punctuation from the duration data
            const punctuation = /[.,\/#!$%\^&\*;:{}=\-_`~()]/g;
            const durationDataItemsNoPunctuation = durationDataItems.map(
                ([key, value]) => [key.replace(punctuation, ""), value]
            );

            //turn the duration data into a dictionary averaging any duplicates
            const durationDataDict = {};
            durationDataItemsNoPunctuation.forEach(([key, value]) => {
                if (durationDataDict[key] == null) {
                    durationDataDict[key] = [value];
                } else {
                    durationDataDict[key].push(value);
                }
            });

            //turn the duration data dictionary into a dictionary with the average
            const durationDataDictAvg = {};
            Object.entries(durationDataDict).forEach(([key, value]) => {
                durationDataDictAvg[key] =
                    value.reduce((a, b) => a + b) / value.length;
            });

            const choose = (a) => a[Math.floor(rnd() * a.length)];
            let sentence = choose(ngrams[""]).split(" ");
            const order = sentence.length;
            var chooseDuration = false;
            while (true) {
                const last = sentence.slice(-order).join(" ").toLowerCase();
                const unmodifiedFollowing = [...(ngrams[last] ?? [])];
                if (unmodifiedFollowing.length <= 0) break;
                let weightedFollowing = [...unmodifiedFollowing];
                console.log(unmodifiedFollowing);

                let trackedWords = {};
                let totalTime = 0;

                unmodifiedFollowing.forEach((element) => {
                    if (durationDataDictAvg[element]) {
                        if (trackedWords[element]) return;
                        trackedWords[element] = durationDataDictAvg[element];
                        totalTime += durationDataDictAvg[element];
                    }
                });
                if (totalTime == 0) {
                    chooseDuration = true;
                    sentence.push(choose(unmodifiedFollowing));
                    continue;
                }

                if (rnd() > bias && !chooseDuration) {
                    sentence.push(choose(unmodifiedFollowing));
                    continue;
                }
                chooseDuration = false;

                let durationBiasedChoices = [];

                Object.entries(trackedWords).forEach((entry) => {
                    const [key, value] = entry;
                    console.log(key, value, (value / totalTime) * 100);
                    for (
                        let index = 0;
                        index < (value / totalTime) * 100;
                        index++
                    ) {
                        durationBiasedChoices.push(key);
                    }
                });
                console.log("duration Bias", durationBiasedChoices, totalTime);

                sentence.push(choose(durationBiasedChoices));
            }
            return sentence;
        }

        function generateMarkovExercise(ngrams, word_count, rnd, bias) {
            let words = [];
            let chars_left = word_count * 5 + 1;
            while (chars_left > 0) {
                const sentence = generate_sentence(ngrams, rnd, bias);
                chars_left -= 1 + sentence.join(" ").length;
                words.splice(words.length, 0, ...sentence);
            }
            return new TypeJig.Exercise(words, 0, false, "ordered");
        }

        //JQuery document ready
        $(document).ready(function () {
            populatePage();

            var fields = parseQueryString(document.location.search);
            var bias = parseFloat(fields["bias"] ?? 40) / 100;

            var rng = new_rng(fields.seed);

            var word_count =
                fields.word_count == null ? 100 : parseInt(fields.word_count);

            var name = "Markov-chain generated sentences";
            const ngrams = compute_ngrams(sentences, 3);
            // console.log(ngrams)
            var exercise = generateMarkovExercise(
                ngrams,
                word_count,
                rng,
                bias
            );

            var jig = setExercise(name, exercise, null, fields);

            var another = document.getElementById("new");
            var nextSeed = prepareNextSeed(another);
            another.addEventListener("click", function (evt) {
                evt.preventDefault();
                window.history.replaceState(
                    "",
                    "",
                    updateURLParameter(window.location.href, "seed", nextSeed)
                );
                let rng = new_rng(nextSeed);
                let exercise = generateMarkovExercise(
                    ngrams,
                    word_count,
                    rng,
                    bias
                );
                jig.exercise = exercise;
                jig.reset();
                nextSeed = prepareNextSeed(another);
            });

            var back = document.getElementById("back");
            back.href = back.href.replace("markov", "form");
            initializeButtons(jig);
        });
    </script>
</html>
